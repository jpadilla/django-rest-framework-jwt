{
    "docs": [
        {
            "location": "/", 
            "text": "REST framework JWT Auth\n\n\nJSON Web Token Authentication support for Django REST Framework\n\n\n\n\nOverview\n\n\nThis package provides \nJSON Web Token Authentication\n support for \nDjango REST framework\n.\n\n\nIf you want to know more about JWT, check out the following resources:\n\n\n\n\nDjangoCon 2014 - JSON Web Tokens \nVideo\n | \nSlides\n\n\nAuth with JSON Web Tokens\n\n\nJWT.io\n\n\n\n\nRequirements\n\n\n\n\nPython (2.7, 3.3, 3.4, 3.5)\n\n\nDjango (1.8, 1.9, 1.10)\n\n\nDjango REST Framework (3.0, 3.1, 3.2, 3.3, 3.4, 3.5)\n\n\n\n\nSecurity\n\n\nUnlike some more typical uses of JWTs, this module only generates\nauthentication tokens that will verify the user who is requesting one of your DRF\nprotected API resources. The actual\nrequest parameters themselves are \nnot\n included in the JWT claims which means\nthey are not signed and may be tampered with. You should only expose your API\nendpoints over SSL/TLS to protect against content tampering and certain kinds of\nreplay attacks.\n\n\nInstallation\n\n\nInstall using \npip\n...\n\n\n$ pip install djangorestframework-jwt\n\n\n\n\nUsage\n\n\nIn your \nsettings.py\n, add \nJSONWebTokenAuthentication\n to Django REST framework's \nDEFAULT_AUTHENTICATION_CLASSES\n.\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n    ),\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.BasicAuthentication',\n    ),\n}\n\n\n\n\nIn your \nurls.py\n add the following URL route to enable obtaining a token via a POST included the user's username and password.\n\n\nfrom rest_framework_jwt.views import obtain_jwt_token\n#...\n\nurlpatterns = [\n    '',\n    # ...\n\n    url(r'^api-token-auth/', obtain_jwt_token),\n]\n\n\n\n\nYou can easily test if the endpoint is working by doing the following in your terminal, if you had a user created with the username \nadmin\n and password \npassword123\n.\n\n\n$ curl -X POST -d \nusername=admin\npassword=password123\n http://localhost:8000/api-token-auth/\n\n\n\n\nAlternatively, you can use all the content types supported by the Django REST framework to obtain the auth token. For example:\n\n\n$ curl -X POST -H \nContent-Type: application/json\n -d '{\nusername\n:\nadmin\n,\npassword\n:\npassword123\n}' http://localhost:8000/api-token-auth/\n\n\n\n\nNow in order to access protected api urls you must include the \nAuthorization: JWT \nyour_token\n header.\n\n\n$ curl -H \nAuthorization: JWT \nyour_token\n http://localhost:8000/protected-url/\n\n\n\n\nRefresh Token\n\n\nIf \nJWT_ALLOW_REFRESH\n is True, \nnon-expired\n tokens can be \"refreshed\" to obtain a brand new token with renewed expiration time. Add a URL pattern like this:\n\n\n    from rest_framework_jwt.views import refresh_jwt_token\n    #  ...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-refresh/', refresh_jwt_token),\n    ]\n\n\n\n\nPass in an existing token to the refresh endpoint as follows: \n{\"token\": EXISTING_TOKEN}\n. Note that only non-expired tokens will work. The JSON response looks the same as the normal obtain token endpoint \n{\"token\": NEW_TOKEN}\n.\n\n\n$ curl -X POST -H \nContent-Type: application/json\n -d '{\ntoken\n:\nEXISTING_TOKEN\n}' http://localhost:8000/api-token-refresh/\n\n\n\n\nRefresh with tokens can be repeated (token1 -\n token2 -\n token3), but this chain of token stores the time that the original token (obtained with username/password credentials), as \norig_iat\n. You can only keep refreshing tokens up to \nJWT_REFRESH_EXPIRATION_DELTA\n.\n\n\nA typical use case might be a web app where you'd like to keep the user \"logged in\" the site without having to re-enter their password, or get kicked out by surprise before their token expired. Imagine they had a 1-hour token and are just at the last minute while they're still doing something. With mobile you could perhaps store the username/password to get a new token, but this is not a great idea in a browser. Each time the user loads the page, you can check if there is an existing non-expired token and if it's close to being expired, refresh it to extend their session. In other words, if a user is actively using your site, they can keep their \"session\" alive.\n\n\nVerify Token\n\n\nIn some microservice architectures, authentication is handled by a single service. Other services delegate the responsibility of confirming that a user is logged in to this authentication service. This usually means that a service will pass a JWT received from the user to the authentication service, and wait for a confirmation that the JWT is valid before returning protected resources to the user.\n\n\nThis setup is supported in this package using a verification endpoint. Add the following URL pattern:\n\n\n    from rest_framework_jwt.views import verify_jwt_token\n\n    #...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-verify/', verify_jwt_token),\n    ]\n\n\n\n\nPassing a token to the verification endpoint will return a 200 response and the token if it is valid. Otherwise, it will return a 400 Bad Request as well as an error identifying why the token was invalid.\n\n\n$ curl -X POST -H \nContent-Type: application/json\n -d '{\ntoken\n:\nEXISTING_TOKEN\n}' http://localhost:8000/api-token-verify/\n\n\n\n\nAdditional Settings\n\n\nThere are some additional settings that you can override similar to how you'd do it with Django REST framework itself. Here are all the available defaults.\n\n\nJWT_AUTH = {\n    'JWT_ENCODE_HANDLER':\n    'rest_framework_jwt.utils.jwt_encode_handler',\n\n    'JWT_DECODE_HANDLER':\n    'rest_framework_jwt.utils.jwt_decode_handler',\n\n    'JWT_PAYLOAD_HANDLER':\n    'rest_framework_jwt.utils.jwt_payload_handler',\n\n    'JWT_PAYLOAD_GET_USER_ID_HANDLER':\n    'rest_framework_jwt.utils.jwt_get_user_id_from_payload_handler',\n\n    'JWT_RESPONSE_PAYLOAD_HANDLER':\n    'rest_framework_jwt.utils.jwt_response_payload_handler',\n\n    'JWT_SECRET_KEY': settings.SECRET_KEY,\n    'JWT_GET_USER_SECRET_KEY': None,\n    'JWT_PUBLIC_KEY': None,\n    'JWT_PRIVATE_KEY': None,\n    'JWT_ALGORITHM': 'HS256',\n    'JWT_VERIFY': True,\n    'JWT_VERIFY_EXPIRATION': True,\n    'JWT_LEEWAY': 0,\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(seconds=300),\n    'JWT_AUDIENCE': None,\n    'JWT_ISSUER': None,\n\n    'JWT_ALLOW_REFRESH': False,\n    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),\n\n    'JWT_AUTH_HEADER_PREFIX': 'JWT',\n    'JWT_AUTH_COOKIE': None,\n\n}\n\n\n\n\nThis packages uses the JSON Web Token Python implementation, \nPyJWT\n and allows to modify some of it's available options.\n\n\nJWT_SECRET_KEY\n\n\nThis is the secret key used to sign the JWT. Make sure this is safe and not shared or public.\n\n\nDefault is your project's \nsettings.SECRET_KEY\n.\n\n\nJWT_GET_USER_SECRET_KEY\n\n\nThis is more robust version of JWT_SECRET_KEY. It is defined per User, so in case token is compromised it can be\neasily changed by owner. Changing this value will make all tokens for given user unusable. Value should be a function, accepting user as only parameter and returning it's secret key.\n\n\nDefault is \nNone\n.\n\n\nJWT_PUBLIC_KEY\n\n\nThis is an object of type \ncryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey\n. It will be used to verify the signature of the incoming JWT. Will override \nJWT_SECRET_KEY\n when set. Read the \ndocumentation\n for more details. Please note that \nJWT_ALGORITHM\n must be set to one of \nRS256\n, \nRS384\n, or \nRS512\n.\n\n\nDefault is \nNone\n.\n\n\nJWT_PRIVATE_KEY\n\n\nThis is an object of type \ncryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey\n. It will be used to sign the signature component of the JWT. Will override \nJWT_SECRET_KEY\n when set. Read the \ndocumentation\n for more details. Please note that \nJWT_ALGORITHM\n must be set to one of \nRS256\n, \nRS384\n, or \nRS512\n.\n\n\nDefault is \nNone\n.\n\n\nJWT_ALGORITHM\n\n\nPossible values are any of the \nsupported algorithms\n for cryptographic signing in PyJWT.\n\n\nDefault is \n\"HS256\"\n.\n\n\nJWT_VERIFY\n\n\nIf the secret is wrong, it will raise a jwt.DecodeError telling you as such. You can still get at the payload by setting the \nJWT_VERIFY\n to \nFalse\n.\n\n\nDefault is \nTrue\n.\n\n\nJWT_VERIFY_EXPIRATION\n\n\nYou can turn off expiration time verification by setting \nJWT_VERIFY_EXPIRATION\n to \nFalse\n.\nWithout expiration verification, JWTs will last forever meaning a leaked token could be used by an attacker indefinitely.\n\n\nDefault is \nTrue\n.\n\n\nJWT_LEEWAY\n\n\nThis allows you to validate an expiration time which is in the past but not very far. For example, if you have a JWT payload with an expiration time set to 30 seconds after creation but you know that sometimes you will process it after 30 seconds, you can set a leeway of 10 seconds in order to have some margin.\n\n\nDefault is \n0\n seconds.\n\n\nJWT_EXPIRATION_DELTA\n\n\nThis is an instance of Python's \ndatetime.timedelta\n. This will be added to \ndatetime.utcnow()\n to set the expiration time.\n\n\nDefault is \ndatetime.timedelta(seconds=300)\n(5 minutes).\n\n\nJWT_AUDIENCE\n\n\nThis is a string that will be checked against the \naud\n field of the token, if present.\n\n\nDefault is \nNone\n(fail if \naud\n present on JWT).\n\n\nJWT_ISSUER\n\n\nThis is a string that will be checked against the \niss\n field of the token.\n\n\nDefault is \nNone\n(do not check \niss\n on JWT).\n\n\nJWT_ALLOW_REFRESH\n\n\nEnable token refresh functionality. Token issued from \nrest_framework_jwt.views.obtain_jwt_token\n will have an \norig_iat\n field. Default is \nFalse\n\n\nJWT_REFRESH_EXPIRATION_DELTA\n\n\nLimit on token refresh, is a \ndatetime.timedelta\n instance. This is how much time after the original token that future tokens can be refreshed from.\n\n\nDefault is \ndatetime.timedelta(days=7)\n (7 days).\n\n\nJWT_PAYLOAD_HANDLER\n\n\nSpecify a custom function to generate the token payload\n\n\nJWT_PAYLOAD_GET_USER_ID_HANDLER\n\n\nIf you store \nuser_id\n differently than the default payload handler does, implement this function to fetch \nuser_id\n from the payload. \nNote:\n Will be deprecated in favor of \nJWT_PAYLOAD_GET_USERNAME_HANDLER\n.\n\n\nJWT_PAYLOAD_GET_USERNAME_HANDLER\n\n\nIf you store \nusername\n differently than the default payload handler does, implement this function to fetch \nusername\n from the payload.\n\n\nJWT_RESPONSE_PAYLOAD_HANDLER\n\n\nResponsible for controlling the response data returned after login or refresh. Override to return a custom response such as including the serialized representation of the User.\n\n\nDefaults to return the JWT token.\n\n\nExample:\n\n\ndef jwt_response_payload_handler(token, user=None, request=None):\n    return {\n        'token': token,\n        'user': UserSerializer(user, context={'request': request}).data\n    }\n\n\n\n\nDefault is \n{'token': token}\n\n\nJWT_AUTH_HEADER_PREFIX\n\n\nYou can modify the Authorization header value prefix that is required to be sent together with the token. The default value is \nJWT\n. This decision was introduced in PR \n#4\n to allow using both this package and OAuth2 in DRF.\n\n\nAnother common value used for tokens and Authorization headers is \nBearer\n.\n\n\nDefault is \nJWT\n.\n\n\nJWT_AUTH_COOKIE\n\n\nYou can set this to a string if you want to use http cookies in addition to the Authorization header as a valid transport for the token.\nThe string you set here will be used as the cookie name that will be set in the response headers when requesting a token. The token validation\nprocedure will also look into this cookie, if set. The 'Authorization' header takes precedence if both the header and the cookie are present in the request.\n\n\nDefault is \nNone\n and no cookie is set when creating tokens nor accepted when validating them.\n\n\nExtending \nJSONWebTokenAuthentication\n\n\nRight now \nJSONWebTokenAuthentication\n assumes that the JWT will come in the header, or a cookie if configured (see \nJWT_AUTH_COOKIE\n). The JWT spec does not require this (see: \nMaking a service Call\n). For example, the JWT may come in the querystring. The ability to send the JWT in the querystring is needed in cases where the user cannot set the header (for example the src element in HTML).\n\n\nTo achieve this functionality, the user might write a custom \nAuthentication\n:\n\n\nclass JSONWebTokenAuthenticationQS(BaseJSONWebTokenAuthentication):\n    def get_jwt_value(self, request):\n         return request.QUERY_PARAMS.get('jwt')\n\n\n\n\nIt is recommended to use \nBaseJSONWebTokenAuthentication\n, a new base class with no logic around parsing the HTTP headers.\n\n\nCreating a new token manually\n\n\nSometimes you may want to manually generate a token, for example to return a token to the user immediately after account creation. You can do this as follows:\n\n\nfrom rest_framework_jwt.settings import api_settings\n\njwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\njwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n\npayload = jwt_payload_handler(user)\ntoken = jwt_encode_handler(payload)", 
            "title": "Home"
        }, 
        {
            "location": "/#rest-framework-jwt-auth", 
            "text": "JSON Web Token Authentication support for Django REST Framework", 
            "title": "REST framework JWT Auth"
        }, 
        {
            "location": "/#overview", 
            "text": "This package provides  JSON Web Token Authentication  support for  Django REST framework .  If you want to know more about JWT, check out the following resources:   DjangoCon 2014 - JSON Web Tokens  Video  |  Slides  Auth with JSON Web Tokens  JWT.io", 
            "title": "Overview"
        }, 
        {
            "location": "/#requirements", 
            "text": "Python (2.7, 3.3, 3.4, 3.5)  Django (1.8, 1.9, 1.10)  Django REST Framework (3.0, 3.1, 3.2, 3.3, 3.4, 3.5)", 
            "title": "Requirements"
        }, 
        {
            "location": "/#security", 
            "text": "Unlike some more typical uses of JWTs, this module only generates\nauthentication tokens that will verify the user who is requesting one of your DRF\nprotected API resources. The actual\nrequest parameters themselves are  not  included in the JWT claims which means\nthey are not signed and may be tampered with. You should only expose your API\nendpoints over SSL/TLS to protect against content tampering and certain kinds of\nreplay attacks.", 
            "title": "Security"
        }, 
        {
            "location": "/#installation", 
            "text": "Install using  pip ...  $ pip install djangorestframework-jwt", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "In your  settings.py , add  JSONWebTokenAuthentication  to Django REST framework's  DEFAULT_AUTHENTICATION_CLASSES .  REST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n    ),\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.BasicAuthentication',\n    ),\n}  In your  urls.py  add the following URL route to enable obtaining a token via a POST included the user's username and password.  from rest_framework_jwt.views import obtain_jwt_token\n#...\n\nurlpatterns = [\n    '',\n    # ...\n\n    url(r'^api-token-auth/', obtain_jwt_token),\n]  You can easily test if the endpoint is working by doing the following in your terminal, if you had a user created with the username  admin  and password  password123 .  $ curl -X POST -d  username=admin password=password123  http://localhost:8000/api-token-auth/  Alternatively, you can use all the content types supported by the Django REST framework to obtain the auth token. For example:  $ curl -X POST -H  Content-Type: application/json  -d '{ username : admin , password : password123 }' http://localhost:8000/api-token-auth/  Now in order to access protected api urls you must include the  Authorization: JWT  your_token  header.  $ curl -H  Authorization: JWT  your_token  http://localhost:8000/protected-url/", 
            "title": "Usage"
        }, 
        {
            "location": "/#refresh-token", 
            "text": "If  JWT_ALLOW_REFRESH  is True,  non-expired  tokens can be \"refreshed\" to obtain a brand new token with renewed expiration time. Add a URL pattern like this:      from rest_framework_jwt.views import refresh_jwt_token\n    #  ...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-refresh/', refresh_jwt_token),\n    ]  Pass in an existing token to the refresh endpoint as follows:  {\"token\": EXISTING_TOKEN} . Note that only non-expired tokens will work. The JSON response looks the same as the normal obtain token endpoint  {\"token\": NEW_TOKEN} .  $ curl -X POST -H  Content-Type: application/json  -d '{ token : EXISTING_TOKEN }' http://localhost:8000/api-token-refresh/  Refresh with tokens can be repeated (token1 -  token2 -  token3), but this chain of token stores the time that the original token (obtained with username/password credentials), as  orig_iat . You can only keep refreshing tokens up to  JWT_REFRESH_EXPIRATION_DELTA .  A typical use case might be a web app where you'd like to keep the user \"logged in\" the site without having to re-enter their password, or get kicked out by surprise before their token expired. Imagine they had a 1-hour token and are just at the last minute while they're still doing something. With mobile you could perhaps store the username/password to get a new token, but this is not a great idea in a browser. Each time the user loads the page, you can check if there is an existing non-expired token and if it's close to being expired, refresh it to extend their session. In other words, if a user is actively using your site, they can keep their \"session\" alive.", 
            "title": "Refresh Token"
        }, 
        {
            "location": "/#verify-token", 
            "text": "In some microservice architectures, authentication is handled by a single service. Other services delegate the responsibility of confirming that a user is logged in to this authentication service. This usually means that a service will pass a JWT received from the user to the authentication service, and wait for a confirmation that the JWT is valid before returning protected resources to the user.  This setup is supported in this package using a verification endpoint. Add the following URL pattern:      from rest_framework_jwt.views import verify_jwt_token\n\n    #...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-verify/', verify_jwt_token),\n    ]  Passing a token to the verification endpoint will return a 200 response and the token if it is valid. Otherwise, it will return a 400 Bad Request as well as an error identifying why the token was invalid.  $ curl -X POST -H  Content-Type: application/json  -d '{ token : EXISTING_TOKEN }' http://localhost:8000/api-token-verify/", 
            "title": "Verify Token"
        }, 
        {
            "location": "/#additional-settings", 
            "text": "There are some additional settings that you can override similar to how you'd do it with Django REST framework itself. Here are all the available defaults.  JWT_AUTH = {\n    'JWT_ENCODE_HANDLER':\n    'rest_framework_jwt.utils.jwt_encode_handler',\n\n    'JWT_DECODE_HANDLER':\n    'rest_framework_jwt.utils.jwt_decode_handler',\n\n    'JWT_PAYLOAD_HANDLER':\n    'rest_framework_jwt.utils.jwt_payload_handler',\n\n    'JWT_PAYLOAD_GET_USER_ID_HANDLER':\n    'rest_framework_jwt.utils.jwt_get_user_id_from_payload_handler',\n\n    'JWT_RESPONSE_PAYLOAD_HANDLER':\n    'rest_framework_jwt.utils.jwt_response_payload_handler',\n\n    'JWT_SECRET_KEY': settings.SECRET_KEY,\n    'JWT_GET_USER_SECRET_KEY': None,\n    'JWT_PUBLIC_KEY': None,\n    'JWT_PRIVATE_KEY': None,\n    'JWT_ALGORITHM': 'HS256',\n    'JWT_VERIFY': True,\n    'JWT_VERIFY_EXPIRATION': True,\n    'JWT_LEEWAY': 0,\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(seconds=300),\n    'JWT_AUDIENCE': None,\n    'JWT_ISSUER': None,\n\n    'JWT_ALLOW_REFRESH': False,\n    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),\n\n    'JWT_AUTH_HEADER_PREFIX': 'JWT',\n    'JWT_AUTH_COOKIE': None,\n\n}  This packages uses the JSON Web Token Python implementation,  PyJWT  and allows to modify some of it's available options.  JWT_SECRET_KEY  This is the secret key used to sign the JWT. Make sure this is safe and not shared or public.  Default is your project's  settings.SECRET_KEY .  JWT_GET_USER_SECRET_KEY  This is more robust version of JWT_SECRET_KEY. It is defined per User, so in case token is compromised it can be\neasily changed by owner. Changing this value will make all tokens for given user unusable. Value should be a function, accepting user as only parameter and returning it's secret key.  Default is  None .  JWT_PUBLIC_KEY  This is an object of type  cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey . It will be used to verify the signature of the incoming JWT. Will override  JWT_SECRET_KEY  when set. Read the  documentation  for more details. Please note that  JWT_ALGORITHM  must be set to one of  RS256 ,  RS384 , or  RS512 .  Default is  None .  JWT_PRIVATE_KEY  This is an object of type  cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey . It will be used to sign the signature component of the JWT. Will override  JWT_SECRET_KEY  when set. Read the  documentation  for more details. Please note that  JWT_ALGORITHM  must be set to one of  RS256 ,  RS384 , or  RS512 .  Default is  None .  JWT_ALGORITHM  Possible values are any of the  supported algorithms  for cryptographic signing in PyJWT.  Default is  \"HS256\" .  JWT_VERIFY  If the secret is wrong, it will raise a jwt.DecodeError telling you as such. You can still get at the payload by setting the  JWT_VERIFY  to  False .  Default is  True .  JWT_VERIFY_EXPIRATION  You can turn off expiration time verification by setting  JWT_VERIFY_EXPIRATION  to  False .\nWithout expiration verification, JWTs will last forever meaning a leaked token could be used by an attacker indefinitely.  Default is  True .  JWT_LEEWAY  This allows you to validate an expiration time which is in the past but not very far. For example, if you have a JWT payload with an expiration time set to 30 seconds after creation but you know that sometimes you will process it after 30 seconds, you can set a leeway of 10 seconds in order to have some margin.  Default is  0  seconds.  JWT_EXPIRATION_DELTA  This is an instance of Python's  datetime.timedelta . This will be added to  datetime.utcnow()  to set the expiration time.  Default is  datetime.timedelta(seconds=300) (5 minutes).  JWT_AUDIENCE  This is a string that will be checked against the  aud  field of the token, if present.  Default is  None (fail if  aud  present on JWT).  JWT_ISSUER  This is a string that will be checked against the  iss  field of the token.  Default is  None (do not check  iss  on JWT).  JWT_ALLOW_REFRESH  Enable token refresh functionality. Token issued from  rest_framework_jwt.views.obtain_jwt_token  will have an  orig_iat  field. Default is  False  JWT_REFRESH_EXPIRATION_DELTA  Limit on token refresh, is a  datetime.timedelta  instance. This is how much time after the original token that future tokens can be refreshed from.  Default is  datetime.timedelta(days=7)  (7 days).  JWT_PAYLOAD_HANDLER  Specify a custom function to generate the token payload  JWT_PAYLOAD_GET_USER_ID_HANDLER  If you store  user_id  differently than the default payload handler does, implement this function to fetch  user_id  from the payload.  Note:  Will be deprecated in favor of  JWT_PAYLOAD_GET_USERNAME_HANDLER .  JWT_PAYLOAD_GET_USERNAME_HANDLER  If you store  username  differently than the default payload handler does, implement this function to fetch  username  from the payload.  JWT_RESPONSE_PAYLOAD_HANDLER  Responsible for controlling the response data returned after login or refresh. Override to return a custom response such as including the serialized representation of the User.  Defaults to return the JWT token.  Example:  def jwt_response_payload_handler(token, user=None, request=None):\n    return {\n        'token': token,\n        'user': UserSerializer(user, context={'request': request}).data\n    }  Default is  {'token': token}  JWT_AUTH_HEADER_PREFIX  You can modify the Authorization header value prefix that is required to be sent together with the token. The default value is  JWT . This decision was introduced in PR  #4  to allow using both this package and OAuth2 in DRF.  Another common value used for tokens and Authorization headers is  Bearer .  Default is  JWT .  JWT_AUTH_COOKIE  You can set this to a string if you want to use http cookies in addition to the Authorization header as a valid transport for the token.\nThe string you set here will be used as the cookie name that will be set in the response headers when requesting a token. The token validation\nprocedure will also look into this cookie, if set. The 'Authorization' header takes precedence if both the header and the cookie are present in the request.  Default is  None  and no cookie is set when creating tokens nor accepted when validating them.", 
            "title": "Additional Settings"
        }, 
        {
            "location": "/#extending-jsonwebtokenauthentication", 
            "text": "Right now  JSONWebTokenAuthentication  assumes that the JWT will come in the header, or a cookie if configured (see  JWT_AUTH_COOKIE ). The JWT spec does not require this (see:  Making a service Call ). For example, the JWT may come in the querystring. The ability to send the JWT in the querystring is needed in cases where the user cannot set the header (for example the src element in HTML).  To achieve this functionality, the user might write a custom  Authentication :  class JSONWebTokenAuthenticationQS(BaseJSONWebTokenAuthentication):\n    def get_jwt_value(self, request):\n         return request.QUERY_PARAMS.get('jwt')  It is recommended to use  BaseJSONWebTokenAuthentication , a new base class with no logic around parsing the HTTP headers.", 
            "title": "Extending JSONWebTokenAuthentication"
        }, 
        {
            "location": "/#creating-a-new-token-manually", 
            "text": "Sometimes you may want to manually generate a token, for example to return a token to the user immediately after account creation. You can do this as follows:  from rest_framework_jwt.settings import api_settings\n\njwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\njwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n\npayload = jwt_payload_handler(user)\ntoken = jwt_encode_handler(payload)", 
            "title": "Creating a new token manually"
        }
    ]
}